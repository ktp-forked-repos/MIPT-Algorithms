		Move semantics & perfect forwarding

На самом деле не все так просто:
-std::move на самомо деле ничего не переносит(move)
-Perfect forwarding is imperfect
-Move операции не всегда такие дешевые, как может показаться
-T&& не всегда представляет собой rvalue ссылку


		std::move
-Важно понимать, что эта конструкция ничего не перемещает. Это всего лишь преобразование типов, наподобии static_cast.
-Говорит компилятору, что из объекта можно "вывозить" (move) данные.
-Использование std::move не всегда приводит к вызову методов с move семантикой. Константный объект превращается в константный rvalue, из которого "вывезти" данные не получится.

--------------------
const v x;
f(v&& p);
f(std::move(x));
const v&&;
--------------------


		std::forward
-В отличие от std::move делает преобразование к rvalue, но только при дополнительных условия.
-Пример применения (важно помнить, что параметр функции - lvalue):

void process(const widget& lvalParam); //process lvalues
void process(Widget&& rvalParam); // process rvalues
template<typename T> void logAndProcess(T&& param) {
	auto now = std::chrono::system_clock::now();
	makeLogEntry("Calling 'process'", now);
	process(std::forward<T>(param));
}

--------------------
T v;
1) (auto&&) x = v;
	  |
	  V
	  v&
2) -.- = std::move(v);
   T&&
--------------------
		
		 Универсальные ссылки и rvalue reference
-Не все конструкции вида T&& являются rvalue reference
void f(Widget&& param); // rvalue reference
Widget&& var1 = Widget(); // rvalue reference
auto&& var2 = var1; // not rvalue reference
template<typename T>
void f(std::vector<T>&& param); //rvalue reference
template<typename T>
void f(T&& param); //not rvalue reference
-Если есть вывод типа - универсальная ссылка, если нет - rvalue reference
-Отличие в использовании: с универсальными ссылками применяем std::forward, с rvalue reference - std::move
-Reference collapsing

		REturn value optimization(RVO)
-"Неоптимизированная" версия функции:

Widget makeWidget() // "Copying" version of makeWidget
{
	Widget w; // local variable
	..//configure w
	return w; // "copy" w into return value	
}

-"Оптимизированная" версия (работает медленнее):
Widget makeWidget() // Moving version of makeWidget
{
	Widget w;
	..
	return std::move(w); // move w into return value
}

		Особенности std::move
-Не стоит переопределять функции, получающие универсальные ссылки в качестве аргумента. Результат может работать не так, как вы думаете. В частности, не стоит определять конструкторы от универсальных ссылок.
-Варианты борьбы: использование другого имени функции, передача параметра как const T& или по значению, или испоьзование фиктивного параметра для перегруженных функций.
-Иногда move-операции у контейнеров недоступны, или небыстрые или могут кидать исключения (и тогда используются операторы копирования).

		Особенности perfect forwarding
-Оно не всегда "perfect"
-std::initializer_list
-0 вместо nullptr
-static const члены класса, с инициализацией в теле класса
-переопределенные функции(компилятор не сможет выбрать, какую из них использовать)
-Битовые поля

