Нет, гарантии взаимного исключения не будет. 
Рассмотрим, например, следующую реализацию функции lock():

void lock(bool thread_index) // нумерация с единицы
{
	/* 1 */ victim_ = thread_index;
	/* 2 */ want_[thread_index] = true;
	/* 3 */ while (want_[3 - thread_index] && victim_ == thread_index)
		std::this_thread::yield();
}

и следующую последовательность инструкций:
1. Оба процесса вызывают lock()
	(want_1 = want_2 = 0)
2. Первый выполняет строчку 1
	(want_1 = want_2 = 0, victim = 1)
3. Второй выполняет строчки 1 и 2
	(want_1 = 0, want_2 = 1, victim = 2)
4. Второй проверяет условие цикла, want_1 == 0, поэтому он не заходит в цикл и выходит из функции
	(want_1 = 0, want_2 = 1, victim = 2, второй в критической секции)
5. Первый выполняет строчку 2
	(want_1 = 1, want_2 = 1, victim = 2, второй в критической секции)
4. Первый проверяет условие цикла, victim == 2, поэтому он не заходит в цикл и выходит из функции
	(want_1 = 0, want_2 = 1, victim = 2, оба потока в критической секции)