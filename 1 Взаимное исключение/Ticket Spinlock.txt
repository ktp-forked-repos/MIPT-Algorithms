Покажем, что значительное снижение производительности наступит когда число потоков превысит число ядер

Рассмотрим случай, когда число потоков не больше числа ядер. 
Тогда каждый поток исполняется на своём ядре и дорогостоящих операций смен контекста не происходит.
N потоков, для простоты считаем, что в данный момент номер каждого потока это и есть его номер билета в очереди ticket_spinlock.
Рассмотрим типичную последовательность выполнения потоков: 

1) Критическая секция первого потока
2) Второй поток выполняет owner_ticket_.load() и сравнивает его с this_thread_ticket
3) Критическая секция второго потока
4) Третий поток выполняет owner_ticket_.load() и сравнивает его с this_thread_ticket
...

Теперь рассмотрим случай, когда число потоков больше числа ядер на k.
В тех же предположениях последовательность будет следующей: 

1) Критическая секция первого потока
2) Второй поток выполняет owner_ticket_.load() и сравнивает его с this_thread_ticket
3) Критическая секция второго потока

Если второй поток ожидает выполнения, а не выполняется, то есть ещё пункт 1.5 (он между 1 и 2)
1.5) Подождать очереди в планировщике ОС

Оценим время работы пункта 1.5: 
В среднем второй поток будет находиться в очереди планировщика в k/n случаях
	в среднем в очереди процессов ОС будет k/2 потоков
    каждый из них будет
    	а) ждать окончания кванта времени одного из выполняющихся потоков
        б) выполнять дорогостоящую операцию переключения контекста

В общем, понятно, что во втором случае будет много дополнительных дорогостоящих операций, 
а значит и частота выполнения критических секций значительно уменшится.

TAS spinlock лишён этой проблемы, ибо в нём нет очереди потоков, 
а значит любой выполняющийся поток может захватить мьютекс, 
то есть нет необходимости в дорогостоящих операциях переключения контекста