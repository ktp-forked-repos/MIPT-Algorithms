Заметим, что в любой момент времени thread_count >= 0. 
Действительно, изначально thread_count == 0 и каждый поток сначала делает один инкремент, 
а потом (независимо от истинности выражения thread_count.fetch_add(1) > 0) через некоторое время ровно один декремент, 
потом снова один инкремент...

Взаимное исключение: 
Понятно, что если какой-то поток находится  в критической секции, то суммарно он выполнил на один инкремент больше чем декремент, 
значит если оба потока в критической секции, то thread_count == 2, 
но тогда посмотрим на поток, который последним вошёл в критическую секцию, 
в момент проверки условия thread_count.fetch_add(1) > 0 другой поток уже в критической секции, 
но тогда thread_count == 1, противоречие, значит tricky_mutex гарантирует взаимное исключение.

Докажем что tricky_mutex не гарантирует свободу от взаимной блокировки. 
Например, рассмотрим такую последовательность выполнения:

1. Первый поток входит в критическую секцию
	(thread_count == 1)
2. Второй поток вошёл в цикл while
	(thread_count == 2)
3. Первый поток вышел из критической секции
	(thread_count == 1)
4. Первый поток вошёл в lock
	(thread_count == 1)
5. Первый поток вошёл в цикл while
    (thread_count == 2)

6. Второй поток выполнил декремент
	(thread_count == 1)
7. Второй поток вошёл в цикл while
	(thread_count == 2)
8. Первый поток выполнил декремент
	(thread_count == 1)
9. Первый поток вошёл в цикл while
	(thread_count == 2)


Далее планирощик процессов может повторять пункты 6-9 неограниченно долго, 
значит tricky_mutex не гарантирует свободу от взаимной блокировки. 